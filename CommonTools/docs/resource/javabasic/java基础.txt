1.Java 运行时数据区域：

   堆内存(Heap):Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。用于存放对象的实例，几乎所有的对象实例都在这里分配内存，是GC管理的主要区域，又被叫做GC堆。
   
         年轻代(Young Generation) ：(默认8:1:1)
               Eden空间 : 新建（New）的，生命周期短的对象存放在Eden区域
	       From Survivor空间,To Survivor空间: 幸存的或者中期的对象将会从Eden区域拷贝到Survivor区域
	 
         老年代(Old Generation)：始终存在或者长期的对象将会从Survivor拷贝到Old Generation,gc回收可能性大的区域。
      
   方法区(Method Area): 它也是一块共享区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
   
          运行时常量池：它是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这部分内容会在类加载后进入方法区的运行时常量池中。
	                虽然运行时常量池具备动态性，但java语言并不要求常量一定要在编译期产生，运行期间也可以放入，典型应用的就是String的intern()方法。
		     
		        tips: 1.String.intern()用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后返回引用。
			
			      2.类变量和成员变量赋默认值的时机：
			        public static Integer a;  //类变量（类加载的准备阶段进行内存分配，并赋初始值）
                                public Integer a;         //实例变量(在对象实例化时会随对象一起分配在java堆中，内存分配完成以后会将分配的内存空间赋零值，保证其在java代码中不赋初始值也可以使用。)
          
	  jdk1.7以后方法区的变迁：在HotSpot中，方法区又被称为PermGen永久代，不是堆区GC线程管理的区域。jdk1.7以后开始去PermGen化，符号引用(Symbols)转移到了native heap，字面量(interned strings)，
	                          类的静态变量(class statics)转移到了java heap，虚拟机加载的类信息被转移到metaspace中。
				
				tips：metaspace并不在虚拟机中，而是使用本地内存。元空间的大小仅受本地内存限制（但是其默认的大小为20M，满了以后会进行metaspace区域的full gc），
				      但可以通过以下参数来指定元空间的大小，-XX:MetaspaceSize -XX:MaxMetaspaceSize指定其大小。
	                          
   
   JVM栈(JVM Stack):
              Java虚拟机栈（Java Virtual Machine Stacks）：是线程私有的，它的生命周期与线程相同，它描述的是Java方法执行的内存模型：
                                                           每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
       					   
              本地方法栈（Native Method Stacks）：与java虚拟机栈类似，它是为虚拟机用到的Native方法服务的。（Native方法:java程序调用其他语言代码的接口）				   
       
   程序计数器：是每个线程私有的，一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
   
   直接内存：其不是JVM运行时数据的一部分，也不是JVM规范中定义的内存区域，但是他也会被频繁的使用并且也会导致OOM异常。
             JDK1.4以后引入了NIO，它是一种基于Channel和Buffer的IO方式，它使用Native函数库直接分配堆外内存，然后通过分配在堆内存中的DirectByteBuffer对象引用这块内存
	     进行操作，避免了数据在native堆和java堆中来回复制。虽然直接内存不会受到Java堆大小的限制，但是只要是是内存也会受到物理机总内存的限制，因此也会出现OOM异常。


2. 虚拟机对象内存模型（仅限于普通java对象，不包括数组对象和Class对象）

     对象的创建：在java语言层面，仅仅是一个new 关键字。但是虚拟机在读到一条new指令以后到底做了什么?
               1.首先检查new指令的参数能否在常量池定位到一个类的符号引用，并检查这个符号代表的类有没有加载解析初始化过，如果没有需要先执行这个类的类加载过程。
	       2.接下来虚拟机为新生的对象分配堆内存，一般对象所需内存大小在类加载完以后就可以确定
	       3.内存分配完成以后给分配的内存空间设置零值（不包括Object Header），保证实例变量（类变量在类加载的准备阶段就会被赋初始值）在java代码中没有赋初值也可以使用。
	       4.对对象进行必要的设置，如这个对象是属于哪个实例，如何找到类的元数据，对象的hash码，对象的gc分代年龄等，这些都会被存放在Object Header中

     对象的内存布局：
          1.Object Header ： 包括两部分数据1.自身的运行时数据，如hashcode，gc分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。
                             2.对象指向它类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
          2.Instances Data ：实例数据，是对象存储的真的有效的信息。
          3.Padding ：       填充对齐，仅仅起着占位的作用， HoSpot VM要求对象的起始地址必须是8字节的整数倍。

     对象访问定位：java程序通过栈中的reference数据来操作堆上的具体对象，目前主流的访问方式有句柄和直接指针两种。
                   对于句柄访问的话，java 堆内存中会开辟一块内存空间作为句柄池，reference中存的是句柄地址，句柄中会存储对象实例的具体数据。
		   对于直接指针，reference中存储的就直接是对象地址。二者都有利有弊，直接指针最大好处就是访问速度快，句柄访问的最大好处就是在对象
		   被移动时(执行垃圾收集操作时，移动对象是很普遍的行为)只需要修改句柄中实例的指针，不用修改reference对象。
			

3. 垃圾收集器： GC需要完成的三件事：1.哪些内存需要回收？ 2.什么时候回收？ 3.如何回收？
     
     1.回收那些 "死去"(即不可能子啊被任何途径使用的对象) 的对象。
   
       如何判断对象已死 ？
         1.引用计数法 : 给对象中添加一个引用计数器，每当有地方引用该对象计数器值加1，当引用失效，计数器值减1。计数器为0的对象就是不可能再被引用。
	                但主流虚拟机很少使用其来管理内存是因为他存在明显的缺陷，无法解决对象之间相互循环引用的问题。			
	                
	 2.可达性分析算法 ：通过一系列称为"GC Roots"的对象作为起点，自这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有和任何一条引用链相连
	                    时，则此对象是不可用的。
			    
			可作为GC Roots的对象包括：1.虚拟机栈中引用的对象 2.方法区中类静态属性引用的对象 3.方法区中常量引用的对象 4.本地方法栈native方法引用的对象。
   
         tips：java中四种引用概念
	       1.强引用（Strong Reference）：程序代码中普遍存在的，类似Object o = new Object()，只要引用还在GC就永远不会回收。
	       2.软引用（Soft Reference）：描述一些还有用但非必需的对象，在内存即将发生OOM之前，会将这些对象进行回收，如果回收以后仍然还没用
	                                   足够内存，才会抛出OOM异常。
	       3.弱引用（Weak Reference）：描述非必需的对象，它的强度比软引用更弱一些，其关联的对象只能存活到下次gc发生之前，当垃圾收集器工作时，无论
                                           内存是否足够，弱引用的对象都会被回收掉。
               4.虚引用（Phantom Reference）:它是最弱的一种引用关系，一个对象是否有虚引用不会对其生命周期有任何影响，也无法通过虚引用获取一个对象的实例，
                                             其被gc回收时会收到一个系统通知。
        
         3.回收方法区：	很多人认为方法区是没用的垃圾收集的，因为在方法区做垃圾回收性价比较低，相比于堆中，尤其新生代一次常规gc能回收70~90%的空间，方法区的GC效率远低于此。
	                其实方法区的垃圾回收包括 1.废弃常量 2.废弃无用的类
	        
                废弃常量：没有任何对象引用常量池中某个常量。
                废弃类：  1.该类所有实例都被回收（java堆中不存在该类任何实例）2.加载该类的classloader也被回收 3.该类对应的java.lang.Class对象没有在任何地方通过反射引用。		
                   
		         -verbose:class
		         -XX:+TraceClassLoading :跟踪类加载的信息(诊断内存泄露很有用)
                         -XX:+TraceClassUnloading :跟踪类卸载的信息(诊断内存泄露很有用)
   
   
    2. 垃圾收集的算法。
          
	    标记-清除算法：算法分为标记和收集两个阶段，首先标记出所有需要回收的对象，然后统一回收被标记的对象。
	                   不足之处，标记和清除两个阶段的效率都不是很高，其次清除之后会产生大量的内存碎片。
			   
	         复制算法：按照内存容量分为大小相等的两块，每次只是用其中的一块，其中一块用完了就将这块上面还存活的对象复制到另一块上，然后再把 使用过的内存一次性全回收掉。
                           这种分配方式简单高效，也不会有内存碎片的情况（目前堆内存新生代回收都采用该算法，Eden -> To Survivor）。不足之处，内存的利用太低只有原来的一半。	 
			   
	    标记-整理算法：先标记出所有要回收的对象，然后让所有存活对象都向一端移动，然后直接清楚掉边界以外的的内存。不足之处也是标记阶段效率不高。
	     
	     分代收集算法：目前大多数商业虚拟机都采用分代收集的算法，根据对象存活周期将内存分为不同几块（java堆分为新生代和老年代），这样就可以根据每个年代的特点使用
	                   不同的收集算法。
       
    3. 垃圾收集器。
            
	    Serial收集器：串行收集器，它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，当它在进行垃圾回收时必须暂停其他线程的工作直到它收集结束。它是新生代的默认收集器。
	    
	    ParNew收集器：Serial收集器的多线程版本，其控制参数，收集算法 ，stop the world,回收策略都和Serial一样。如果老年代使用了CMS作为收集器，新生代就只能使用ParNew收集器，
	                  其jvm参数配置如下：-XX:ParallelGCThreads=20(限制垃圾收集线程数) -XX:+UseConcMarkSweepGC(指定老年代使用CMS收集器) 
			                     -XX:+UseParNewGC(指定年轻代使用ParNew收集器) -XX:+CMSConcurrentMTEnabled (默认开启，启用时并发的CMS阶段将以多线程执行)
	    
            Parallel Scavenge 收集器：并行清除收集器，是新生代的收集器，使用复制算法，并行的多线程收集器。与其他收集器尽量缩短垃圾收集时用户线程的停顿时间不同，它的目标是达到一个可控制的
	                              吞吐量。吞吐量 = 运行用户代码时间/( 运行用户代码时间 + 垃圾收集时间 )，高吞吐量可以高效的利用cpu时间。 
				      其jvm参数配置如下： -XX:MaxGCPauseMills：设置最大垃圾收集停顿时间 -XX:GCTimeRatio:设置吞吐量大小，它的值是一个 0-100 之间的整数。
   
            Serial Old 收集器 ：Serial收集器的老年代版本，使用标记-整理算法。
	    
            Parallel Old 收集器：Parallel Scavenge收集器的老年代版本，使用标记-整理算法和多线程。配合Parallel Scavenge 收集器使用达到吞吐量优先的目标
   
            CMS收集器（concurrent mark sweep 并发标记清除）：使用标记-清除算法，其中初始标记和重新标记需要stop the world
	    
	               1.初始标记：仅标记一下GC Roots能够直接关联到的对象，速度很快。
	               2.并发标记：GC Roots 追踪的过程
		       3.重新标记：为了修正并发标记期间，由于用户程序继续工作而导致标记产生变动的那部分对象
		       4.并发清除：回收标记的无用对象
		       
		CMS收集器优点主要在于并发收集，低停顿，因为的它的并发标记和并发清除两个阶段适合用户线程一起执行的。但是她还有3个明显的缺点，
		1.对cpu资源非常敏感，GC线程会占用一部分cpu资源导致程序变慢。2.无法收集浮动垃圾 3.基于标记-清除算法实现的会导致大量内存碎片。
   
            G1收集器 ：为了尽量缩短处理超大堆（大于4GB）时产生的停顿，相对于CMS的优势而言是内存碎片的产生率大大降低。
	               -XX:+UseG1GC -Xmx32g(最大堆内存为32g) -XX:MaxGCPauseMillis=200(最大暂停时间为200ms) 
                       
		       G1将新生代，老年代的物理空间划分取消了，取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器。
		       这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。
                       Region包括:Eden,Survivor,old,Humongous(如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。其默认直接会被分配在年老代，
		       但是如果它是一个短期存在的巨型对象，就会被分配在Humongous区中)。
		       G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World。在某些情况下G1也会触发full gc，如一个H区无法装下一个巨星对象，为了找到连续的H区，
		       不得不启动Full GC，这时G1会退化使用Serial收集器来完成垃圾的清理工作。
   
     4. 内存分配于回收策略
     
        1.对象优先在Eden区分配，当Eden区没有足够空间，虚拟机将发起一次Minor GC。
	2.大对象(需要大量连续内存空间的java对象，如很长的字符串或者byte[])直接进入老年代。-XX:PretenureSizeThreshold 指定大对象的大小
	3.长期存活的对象直接进入老年区，-XX:MaxTenuringThreshold 对象晋升老年代的年龄阈值
         
	
 4. JVM性能监控和故障处理工具
 
       1.jps 命令 ；jps [option] [hostid] 查看虚拟机进程状况
       2.jstat 命令 ：jstat [option] pid 虚拟机统计信息监控工具 例如：jstat -gc 9  查看进程的gc统计信息          jstat -gcmetacapacity 9 查看进程的metaspace gc统计信息 
       3.jmap 命令 ：jmap [option] pid   java 内存映像工具 例如：jmap -heap  9 显示java堆的详细信息 
                                                             jmap -dump:format=b,file=test.dump 9  生成java堆转储快照
							     jmap -histo 9 查看JVM堆中对象详细占用情况
       4.jinfo命令：jinfo [option] pid  实时的查看和调整虚拟机的各项参数 例如 ：jinfo -flag GCLogFileSize 8807 （查看）jinfo -flag -PrintGCDetails 12278 （关闭gc日志功能）
       5.jstack 命令：jinfo [option] pid  java堆栈跟踪工具 例如 ： jstack -l 9
       6.JDK的可视化工具：
           JConsole 使用 1.配置相关jvm参数 -Dcom.sun.management.jmxremote.port=8999 
                                        -Dcom.sun.management.jmxremote.authenticate=false  
                                        -Dcom.sun.management.jmxremote.ssl=false 
                          指定端口号 && 无认证连接
		    
		         2.去jdk的目录打开JConsole客户端，输入host:port远程连接
   
   
  5.JVM的类加载机制：指JVM把描述类的数据从Class文件加载到内存，并进行数据校验，解析转换和初始化，最终形成被虚拟机可以直接使用的java类型的过程。
    
    1 . 类加载的过程：
           加载：
	        1.通过一个类的全限定名来获取此类的二进制流 
		2.将字节流所代表的静态存储结构转化成方法区的运行时数据 
		3.在内存中生成一个代表该类的java.lang.Class对象，作为方法区这些数据的访问入口（hostspot在方法区中）
	   
	   验证：文件格式验证，元数据验证，字节码验证 ，符号引用验证
	        确保Class文件中的字节流包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身安全。
	   
	   准备：
	        正式为类变量分配内存并设置类变量（只是static修饰的变量，不包括类的成员变量）初始值的阶段，这些内存都将在方法区中进行分配。
		通常情况下在内存地址被分配以后，会对这些地址赋零值（用户指定的初始值会在初始化阶段重新赋上去）。一些特殊的情况如类字段的属性
		存在ConstantValue属性，那么在准备阶段就会赋上ConstantValue属性指定的值（例如 final 修饰的变量在编译时就会生成ConstantValue属性，可以理解为在编译时就放入常量池中）。
	       
	   解析：1.类、接口的解析 2.字段解析 3.类方法解析 4.接口方法解析
	   
	         解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。
	   
	   初始化：
	         通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。
    
	        初始化的时机（加载，验证，准备，解析的过程必然要在此之前开始）：
	          1.遇到new getstatic putstatic invokestatic 这四条指令，如果相关的类没有进行初始化，则需要初始化。例如使用new 实例化对象，访问类的静态方法，
		    访问类的静态变量（final修饰的除外，因为这是一种常量，编译器把他们当作值(value)而不是域(field)来对待，编译器并不会生成字节码来从对象中载入域的值，
		    而是直接把这个值插入到字节码中，这是一种很有用的优化。）
		    
	          2.反射去调用一个类，如(Class.forName("my.xyz.Test"))时如果相关的类没有进行初始化，则需要初始化。
		  
		  3.当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化。
		  
		  4.虚拟机启动时，定义了main()方法的那个类先初始化
	  
      
                tips ：static代码块会在类实例化的时候执行，知道这，我们就可以把类实例化之前要做的事情放在静态代码块中来执行了.
  
  
     2 . 类加载器：把通过'类全名'来获取定义此类的二进制字节流这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。
              
         类与类加载器：
	       类唯一的识别是 ClassLoader id + PackageName + ClassName，只有这三个都一致的类才是同一个类。
	       
	 双亲委派模式：
	             从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。
	             另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。
		     Java程序一般会使用到以下三种系统提供的类加载器，启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），应用程序类加载器（Application ClassLoader）。
	       
	    工作流程 ： 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。
	                如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，
	                因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。  
  
            为什么要这么做？
	              这样做的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，
		      最终都是由启动类加载器进行加载（因为Object对象在rt.jar中,该jar在jdk中，由Bootstrap ClassLoader负责加载），因此Object类在程序的各种类加载器环境中都是同一个类。
	              否则的话用户自己定义一个java.lang.Object类放在程序的classpath下，那系统中就会出现多个不同的Object类，java类体系中最基础的行为就无法保证。
		    
  
         自定义类加载器 ：只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。
  
                      tips：自定义的类加载器去加载一个以java.lang开头的类也无法成功，JVM会抛出一个java.lang.SecurityException。
		     
  
         破坏双亲委派模式：
	          近年来的热码替换，模块热部署等应用要求不用重启java虚拟机就可以实现代码模块的即插即用，催生了OSGi技术。
		  在OSGi中类加载器体系被发展为网状结构，OSGi也没有完全遵循双亲委派模型。
  
  
  
  6 . 类加载及执行子系统案例
      1.OSGI技术（JAVA动态模块系统）
      2.字节码生成与动态代理技术
  
  7 . java内存模型(JMM)与线程
  
      java内存模型：其主要目标是定义程序中各个变量的访问规则，来屏蔽掉各种硬件和操作系统的内存访问差异，让java程在不同平台下都能达到一致的访问效果。
      
